# [2024 郑州CCPC G:Same Sum][https://qoj.ac/problem/9774] 题解

## 简化题意：

你有一个长度为 $n$ 的序列，要处理 $q$ 次操作，操作有两种:

 $1$ $L$ $R$ $v$ 对于 $a_i \in [L,R] ，a_i$ 更新为 $a_i+v$ 

$2$ $L$ $R$ 判断 $a_i，i\in[L,R]$ 是否能划分为 $\frac{R-L+1}{2}$ 对数，且任意两对数的总和相等.

$1\le n,q\le 2\times 10^5$,$0 \le a_i \le 2\times 10^5$

## 题解：

​	看到题目操作一很多数据结构都能维护，但操作二不好判断，一时可能没有思路.

​	先不考虑操作一，考虑序列能否被划分的判据.区间数字之和确定，划分对数确定，每对数字的和也是定值：$\mathrm{sum}=\frac{\sum_{i=L}^{R} a_i}{\frac{R-L+1}{2}}$.考虑check的本质是区间内对于每一个值$a_i$，看是否存在对应个数的$sum-a_i$.手玩几组样例可以发现Yes的序列一定是关于$(\frac{L+R}2,\frac{\mathrm{sum}}{2})$中心对称的.于是命题转化为一个**可重集反转**后（$x$变为$sum-i$）s是否和原可重集等价. 而判断两个序列是否等价我们就需要构造出序列的一个唯一表示法. 例如这里用类似将其转化为一个p进制数的方法用哈希表示，而且由于哈希是$\mathrm{num}\times p^{a}$，可以快速实现反转，即乘以它的倒数. 发现只需普通的线段树就可以维护区间修改和判断.

​	具体的：我们用线段树维护每个区间的sum，$\mathrm{hash1}=\sum^R_{i=L}p^{a_i}$，$\mathrm{hash2}=\frac1{\sum^R_{i=L}p^{a_i}}$，区间可被划分的判据为：$hash1=hash2\times p^{sum}$当然，一切都是在模意义下进行.时间复杂度：$\Theta(qlog_2n+nlog_2n)$​

​	拓展反思：本题妙点是将关于$(\frac{L+R}2,\frac{\mathrm{sum}}{2})$中心对称”转成哈希判断. 

​	类似题目：序列区间加，问是否存在c使区间$l_1,r_1$每个数加c后与$l_2,r_2$等价。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =8e5+7;
#define int long long
const int base=7;
const int invbase=142857144;
const int mod=1e9+7;
int a[N],root,tot;
struct T{
    int l,r,sum,add;
    int hash1,hash2;
}t[N];
int newnode(int l,int r){
    t[++tot]={-1,-1,0,0,(r-l+1),r-l+1};
    return tot;
}
int powwer(int a,int b){
    int ans=1,B=a;
    while(b){
        if(b&1){
            ans*=B;
            ans%=mod;
        }
        B*=B;B%=mod;b>>=1;
    }
    return ans;
}
int inv(int a){
    return powwer(a,mod-2);
}
void addtag(int p,int x,int l,int r){
    t[p].sum+=(r-l+1)*x;
    t[p].hash1*=powwer(base,x);
    t[p].hash1%=mod;
    t[p].hash2*=powwer(invbase,x);
    t[p].hash2%=mod;
    t[p].add+=x;
}
void pushup(int p){
    int l=t[p].l,r=t[p].r;
    t[p].hash1=(t[l].hash1+t[r].hash1)%mod;
    t[p].hash2=(t[l].hash2+t[r].hash2)%mod;
    t[p].sum=t[l].sum+t[r].sum;
}
void spread(int p,int l,int r){
    if(!t[p].add){
        return ;
    }
    int mid=(l+r)>>1;
    if(t[p].l==-1){
        t[p].l=newnode(l,mid);
    }
    if(t[p].r==-1){
        t[p].r=newnode(mid+1,r);
    }
    addtag(t[p].l,t[p].add,l,mid);
    addtag(t[p].r,t[p].add,mid+1,r);
    t[p].add=0;
}
void add(int &p,int L,int R,int l,int r,int x){
    if(p==-1){
        p=newnode(l,r);
    }
    if(l>=L&&r<=R){
        addtag(p,x,l,r);
        return ;
    }
    int mid=(l+r)>>1;
    spread(p,l,r);
    if(mid>=L){
        add(t[p].l,L,R,l,mid,x);
    }
    if(mid<R){
        add(t[p].r,L,R,mid+1,r,x);
    }
    pushup(p);
}
T merge(T a,T b){
    T ans;
    ans.hash1=(a.hash1+b.hash1)%mod;
    ans.hash2=(a.hash2+b.hash2)%mod;
    ans.sum=a.sum+b.sum;
    return ans;
}
T query(int &p,int L,int R,int l,int r){
    if(p==-1){
        p=newnode(l,r);
    }
    if(l>=L&&r<=R){
        return t[p];
    }
    int mid=(l+r)>>1;
    spread(p,l,r);
    T ans={0,0,0,0,0,0};
    if(mid>=L){
        ans=merge(ans,query(t[p].l,L,R,l,mid));
    }
    if(mid<R){
        ans=merge(ans,query(t[p].r,L,R,mid+1,r));
    }
    return ans;
}
signed main(){
    ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    int n,q;
    cin>>n>>q;
    root=newnode(1,n);
    for(int i=1;i<=n;++i){
        cin>>a[i];
        add(root,i,i,1,n,a[i]);
    }
    int q1,l,r,v;
    for(int i=1;i<=q;++i){
        cin>>q1>>l>>r;
        if(q1==1){
            cin>>v;
            add(root,l,r,1,n,v);
        }else{
            T p=query(root,l,r,1,n);
            if((p.sum*2)%(r-l+1)==0&&p.hash1==(p.hash2*powwer(base,p.sum*2/(r-l+1)))%mod){
                puts("YES");
            }else{
                puts("NO");
            }
        }
    }
    return 0;
}
```

