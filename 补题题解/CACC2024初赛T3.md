# [CACC2024初赛T3](https://snail.cronlygames.cn/problem/P1684)

给定一个长度为 N 的数组，每次可以对数组进行以下操作：

- 对区间 [s,t] 内所有的奇数加上某个数，
- 对区间 [s,t] 内所有的偶数加上某个数，
- 查询区间 [s,t] 内所有数的总和。

## 题解

​	本质上维护两个集合，并且相互转移。

​	维护S(区间和)，a0（奇数还没有下传）,a1（偶数还没有下传）,num0（区间0的个数）,

​	设区间长为 $L$，当前奇数个数 $C_1$、偶数个数 $C_0=L-C_1$。
 	一次“给当前偶/奇加 $x_0/x_1$”：
$$
S\leftarrow S + C_0x_0 + C_1x_1 \\\\
e_0=x_0\&1,\ e_1=x_1\&1 \\\\
\begin{aligned}
C_0'&=(e_0?0:C_0)+(e_1?C_1:0) \\\\
C_1'&=(e_0?C_0:0)+(e_1?0:C_1)
\end{aligned}
$$
​	懒标重标（旧懒 $(a_0,a_1)$ 变成新懒）：
$$
\begin{aligned}
a_0'&=(e_0?0:a_0)+(e_1?a_1:0)+x_0 \\\\
a_1'&=(e_0?a_0:0)+(e_1?0:a_1)+x_1
\end{aligned}
$$
## 加强

​		给定长度为 $N$ 的数组（初始为 0）。定义元素的**类别**为其当前值对 $K$ 取模得到的余数（$0..K-1$）。有两类操作：

​		`1 s t mask d`：对区间 $[s,t]$ 中，**当前余数属于 mask 指定集合**的所有元素，加上整数 $d$。
​    （`mask` 用二进制位表示选择的余数集合，第 $i$ 位表示余数 $i$。加上 $d$ 后，这些元素的余数会整体**向右轮转** $r\equiv d\bmod K$；不在集合里的元素不变。）
​		`2 s t`：查询区间 $[s,t]$ 的元素和。

​		$N\le 4\cdot 10^5$，$K\le 10$（或更小），操作次数 $M\le 4\cdot 10^5$，$|d|$ 可大。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N =4000000 + 7;
int n,m,a[N],tot;
struct T{
    int l,r,sum,add0,add1,num0,num1;
}t[N];
int newnode(){
    t[++tot]={-1,-1,0,0,0,0,0};
    return tot;
}
void pushup(int p){
    t[p].sum=t[t[p].l].sum+t[t[p].r].sum;
    t[p].num1=t[t[p].l].num1+t[t[p].r].num1;
    t[p].num0=t[t[p].l].num0+t[t[p].r].num0;
}
void build(int &p,int l,int r){
    if(p==-1)p=newnode();
    if(l==r){
        t[p].sum=0;
        t[p].num0=1;
        return ;
    }
    int mid=(l+r)>>1;
    build(t[p].l,l,mid);
    build(t[p].r,mid+1,r);
    pushup(p);
}
void addtag(int p,int l,int r,int x0,int x1){
    if(p==-1)return;
    t[p].sum+=t[p].num0*x0+t[p].num1*x1;
    if((t[p].add0&1)==0) t[p].add0+=x0; else t[p].add0+=x1;
    if((t[p].add1&1)==0) t[p].add1+=x1; else t[p].add1+=x0;
    if((x0&1)&&(x0&1))swap(t[p].num0,t[p].num1);
    if(x0&1){ t[p].num1+=t[p].num0; t[p].num0=0; }//有负数别用%
    if(x1&1){ t[p].num0+=t[p].num1; t[p].num1=0; }
}
void spread(int p,int L,int R){
    if(L==R)return ;
    if (p == -1) return;
    if (t[p].add0 == 0 && t[p].add1 == 0) return;
    int l=t[p].l,r=t[p].r,len=R-L+1,mid=(L+R)>>1;
    addtag(l,L,mid,t[p].add0,t[p].add1);
    addtag(r,mid+1,R,t[p].add0,t[p].add1);
    t[p].add0=0,t[p].add1=0;
}
void add(int p,int L,int R,int l,int r,int odd,int x){
    if (p == -1) return;
    if (R < l || r < L) return;
    if(L<=l&&R>=r){
        if(odd%2==0){
            addtag(p,l,r,x,0);
        }else{
            addtag(p,l,r,0,x);
        }
        return ;
    }
    spread(p,l,r);
    int mid=(l+r)>>1;
    if(mid>=L)
    add(t[p].l,L,R,l,mid,odd,x);
    if(mid<R)
    add(t[p].r,L,R,mid+1,r,odd,x);
    pushup(p);
}
int query(int p,int L,int R,int l,int r){
    if (p == -1) return 0;
    if (R < l || r < L) return 0;  
    if(L<=l&&R>=r){
        return t[p].sum;
    }
    spread(p,l,r);
    int mid=(l+r)>>1,ans=0;
    if(mid>=L)
    ans+=query(t[p].l,L,R,l,mid);
    if(mid<R)
    ans+=query(t[p].r,L,R,mid+1,r);
    return ans;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n>>m;
    int root=-1;
    build(root,1,n);
    int q,l,r,o,c;
    for(int i=1;i<=m;++i) {
        cin>>q>>l>>r;
        if(q==1){
            cin>>o>>c;
            add(root,l,r,1,n,o,c);
        }else{
            printf("%lld\n",query(root,l,r,1,n));
        }
    }
    return 0;
}
```

